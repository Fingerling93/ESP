#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <limits.h>
#include <ctype.h>

#define ADD_CMD 1
#define DRAW_ALL_CMD 2
#define DRAW_CMD 3
#define RELATIONSHIP_CMD 4
#define LIST_CMD 5
#define QUIT_CMD 6
#define EOF_CMD 7

enum gender
{
    male = 1,
    female = 2,
};

enum relation
{
    sister = 1,
    brother = 2,
    mother = 3,
    father = 4,
    aunt = 5,
    uncle = 6,
    grandmother = 7,
    grandfather = 8,
    mgm = 9,
    fgm = 10,
    mgf = 11,
    fgf = 12,
};
enum addPerson{person1, person2,};

typedef struct _person_
{
    char name;
}person;

typedef struct _user_input_   // used for breaking input string into multiple strings( command, name, relation, gender)..
{
    char *command;
    char *name;
    char gender;
    char *relation;
    char *identity;
    char genderTwo;
}userInput;


// Function Prototype (commands which user can input)
char commandAdd();
char commandDrawAll();
char commandDraw();
char commandRelationship();
char commandList();
int quit();
char inputTerminalCommands(char *input);

//********************************************************************************************************//
char inputTerminalCommands(char *input) // takes char input from main and compares type of command
{
    /*
Using strchr we can iterate through the string, parsing command name
gender relation sex. This will fail if there are more than one space
between words but additional logic could be added to solve multiple
spaces. It also fails if the format command name relation name
is not observed but again additional logic could be added to handle that.
Checks need to be added to handle a failure of malloc.
*/
    userInput item;
    char *start = NULL;
    char *stop = NULL;
    int span = 0;
    userInput item;
          //with strchr it will parse first word, ( store string after " " in stop, whole string is in start var)
    start = input;
    if ( ( stop = strchr ( start, ' '))) {
        span = stop - start;               // equal to ( string without first word - whole string ( if command add, than spin = 3))
        item.command = malloc ( span + 1);  // allocate space for first string
        memmove ( item.command, start, span);
        item.command[span] = '\0';
    }
    //parsing name - each name begins with Capital letter
    start = stop + 1;
    stop = start;;
    while ( ( stop = strchr ( stop, ' '))) {
        if ( !isupper( *(stop + 1))) {
            span = stop - start;
            item.name = malloc ( span + 1);
            memmove ( item.name, start, span);
            item.name[span] = '\0';
            break;
        }
        stop = stop + 1;
    }
    //store  gender - one character inside brackets []
    start = stop;
    item.gender = '*';
    if ( *(start + 1) == '[') {
        item.gender = *(start + 2);
        stop = strchr ( start + 1, ' ');
    }
    //store  relation
    start = stop + 1;
    if ( ( stop = strchr ( start, ' '))) {
        span = stop - start;
        item.relation = malloc ( span + 1);
        memmove ( item.relation, start, span);
        item.relation[span] = '\0';
    }
    //parse name - could be many words, each begins with upper case
    start = stop + 1;
    stop = start;;
    while ( ( stop = strchr ( stop, ' '))) {
        if ( !isupper( *(stop + 1))) {
            span = stop - start;
            item.identity = malloc ( span + 1);
            memmove ( item.identity, start, span);
            item.identity[span] = '\0';
            break;
        }
        stop = stop + 1;
    }
    if ( !stop) { // if nothing follows identity...strchr failed on last name
        span = strlen ( start);
        item.identity = malloc ( span + 1);
        memmove ( item.identity, start, span);
        item.identity[span] = '\0';
        stop = start + span;
    }
    // - store genderTwo - one character inside brackets []
    start = stop;
    item.genderTwo = '*';
    if ( *(start + 1) == '[') {
        item.genderTwo = *(start + 2);
    }
        // this part only for testing
    printf ( "%s\n", item.command);
    printf ( "%s\n", item.name);
    printf ( "%c\n", item.gender);
    printf ( "%s\n", item.relation);
    printf ( "%s\n", item.identity);
    printf ( "%c\n", item.genderTwo);

    free ( item.command);
    free ( item.name);
    free ( item.relation);
    free ( item.identity);


    // *****************************/////
    int i = 0;
    char *str = input;
    char *split = strtok(str, " ");  // split string into words after "space"
    char *array[8] ;
    while(split!= 0)
    {
        array[i++] = split;
        split = strtok(NULL, " ");
    }

    //return 0;


    if (!strcmp(array[0], "add")) { // compare commands ( not sure if correct to do so)
        printf("its add\n");
        return ADD_CMD;

    }
    else if (!strcmp(array[0], "draw-all"))
    {
        printf("its draw-all\n");
        return DRAW_ALL_CMD;
    }
    else if(!strcmp(array[0], "draw"))
    {
        printf("its draw\n");
        return DRAW_CMD;
    }
    else if(!strcmp(array[0], "relationship"))
    {
        printf("its relationship\n");
        return RELATIONSHIP_CMD;
    }
    else if(!strcmp(array[0], "list"))
    {
        printf("its list\n");
        return LIST_CMD;
    }
    else if(!strcmp(array[0], "quit"))
    {
        printf("its quit\n");
        return QUIT_CMD;
    }
    else if(!strcmp(array[0], "EOF"))
    {
        printf("its EOF\n");
        return EOF_CMD;
    }

    /*  char command_add(char *input)
    {
      printf("Evo me\n");
    }*/
return 0;
}
///////////////////////////////////////////////////////////////
//	MAIN MAIN MAIN MAIN MAIN MAIN MAIN MAIN MAIN MAIN MAIN   //
//	  													     //
///////////////////////////////////////////////////////////////
    int main(int argc, char *argv[]) {
        int len_max = 256;
        char *input = (char *) malloc(len_max * sizeof(char)); // memory for input , used for storing commands.
        FILE *fp;

        if (input == NULL) {
            printf("[ERR] Out of memory.\n");
            return 2;
        }
        if (argc == 1) // if program started only with ./ass, load input from user
        {
            while(1)
            {
                printf("esp> "); // read last char \n as \0 so "esp>" does not skip a line
                char read[len_max];
                input = fgets(read, len_max, stdin);
                int len= strlen(read);

                if(read[len-1] == '\n')
                {
                    read[len-1] = '\0';
                }

                inputTerminalCommands(input);
            }
        }
        else if (argc == 2) // check parameters when starting program
        {
            const char *dot = strrchr(argv[1], '.'); // check for . (dot) and store it in *dot

            if (strcmp(dot, ".dot") == 0) // if .dot exists:
            {
                printf("%s\n", dot);
                fp = fopen(argv[1], "a+"); // a+ opens file for reading and appending ( check if other type needed! )
            }
            else if (strcmp(dot, ".dot"))
            {
                   printf("Usage: ./ass [file-name]\n");
                   return 2;
            }

        }
        else if (argc > 2)
        {
             printf("Usage: ./ass [file-name]\n");
             return 1;
        }
    free(input);
    return 0;
    }





