//-----------------------------------------------------------------------------
// assa.c
// Familly tree for ancestry research
// Group: 1, study assistant Philip Hafner
// Authors: 
// Oleksii Sapov 0873049
// Nikola Balac 1231799
// Last changes: 22.12.2016
//-----------------------------------------------------------------------------
//


#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <limits.h>
#include <ctype.h>


#define ADD_CMD 1
#define DRAW_ALL_CMD 2
#define DRAW_CMD 3
#define RELATIONSHIP_CMD 4
#define LIST_CMD 5
#define QUIT_CMD 6
#define EOF_CMD 7
#define ERROR_INVALID_PARAM 1
#define SUCCESSFUL 0
#define ERROR_ADD_1 "[ERR] Wrong usage - add <namePerson1> [m/f] <relation> <namePerson2> [m/f].\n"
#define ERROR_ADD_2 "[ERR] Sex does not match with relation.\n"
#define ERORR_ADD_3 "[ERR] Both people are the same.\n"
#define ERORR_ADD_4 "[ERR] Relation not possible.\n"

enum _Gender_
{
  MALE = 1,
  FEMALE = 2,
};

enum _Relation_
{
  SISTER = 1,
  BROTHER = 2,
  MOTHER = 3,
  FATHER = 4,
  AUNT = 5,
  UNCEL = 6,
  GRANDMOTHER = 7,
  GRANDFATHER = 8,
  MGM = 9,
  FGM = 10,
  MGF = 11,
  FGF = 12,
};

enum _AddPerson_ 
{
  person1,
  person2
};

typedef struct _Person_
{
    char* name_;
    char gender_;
    struct _Person_* mgm_;
    struct _Person_* mgf_;
    struct _Person_* fgm_;
    struct _Person_* fgf_;
    struct _Person_* father_;
    struct _Person_* mother_;
    struct _Person_* next_;
    struct _Person_* prev_;
} Person;

// breaks input string into multiple strings (command, name, relation, gender...)
struct userInput   
{
    char* command_;
    char* name_;
    char gender_;
    char gender_two_;
    char* relation_;
    char* identity_;
    
};

// Function Prototypes (commands which user can input)
int addCommand(char** input);
int drawAllCommand(char** input);
int drawCommand(char** input);
int relationshipCommand(char** input);
int listCommand(char** input);
int quit();
char eofCommand();
int handleUserInput(char* input);
int quitCommand(char** input);
void displayErrorMessage(char* message);


//-----------------------------------------------------------------------------
///
/// This is an example header comment for functions. Copypaste and adapt it!
///
/// @param human The human to check.
/// @param number_to_return_if_not_married The number to return if the human
///        is not married. Should be 0 or 1 for example purposes.
///
/// @return int age of spouse
//
void displayErrorMessage(char* message)
{
   printf("%s\n", message);
}

int addCommand(char* input[]) 
{
    //check all strings from input
   /*   printf("one input: %c\n",input[1][0]);
    char* gender = NULL;

    for (int i = 0; input[1][i] != '\0'; i++)    // check input[1] if only alphabetic
        {
            if(isalpha( input[1][i] ))
            {
                printf("alphabetic name\n");
            }
            else        // if name contains invalid chars, print error
            {
                displayErrorMessage(ERROR_ADD_1);
            }
        }
   // printf("first name: %s\n", firstName);

    if(input[2][0] == '[')  // check if first char of input[2] last name or gender('[')
    {
        printf("input[2] is gender\n");
        if(strcmp(input[2],"[m]") || strcmp(input[2],"[f]")) // check if gender correct type ( [m] or [f] );
        {
            printf("uslo\n");
            displayErrorMessage(ERROR_ADD_1);
        }
        else
        {
            gender = input[2];
            printf("ok\n");
        }
    }
    else
    {               // input[2] does not have "[" and its considered as last name...
        for(int p = 0;input[2][p] != '\0';p++ )
        {
            if(isalpha(input[2][p]))  // check if only alphabetic
            {
                printf("check last name ok\n");
                ;
            }
            else
            {
                displayErrorMessage(ERROR_ADD_1);
            }
        }

    }



    //displayErrorMessage(ERROR_ADD_1);
*/
    return SUCCESSFUL;





    displayErrorMessage(ERROR_ADD_1);

    return SUCCESSFUL;
}

int drawAllCommand(char** input)
{
    printf("drawAllCommand");
    return 0;
}

int drawCommand(char** input)
{
   printf("drawCommand");
   return 0;
}

int relationshipCommand(char** input)
{
    printf("relationshipCommand");
    return 0;
}

int listCommand(char** input)
{
    printf("listCommand");
    return 0;
}

char eofCommand()
{
    printf("EOF");
    return 0;
}

int quitCommand(char* input[])
{
    printf("Bye.\n");

    return 0;
}

//********************************************************************************************************//
int handleUserInput(char* input) // takes char input from main and compares type of command
{
    printf("input: %s\n", input);
    char* in[8];
    int i = 0;
    char* temp;
    char delimiter[] = " ";
    temp = strtok(input, delimiter);
    in[i++] = temp;
    while(temp != NULL)
    {
        temp = strtok(NULL, delimiter);
        in[i++] = temp;
        // printf("%s\n", temp);
    }
    if(!strcmp(in[0], "add"))
    {
        addCommand(in);
    }
    else if (!strcmp(in[0], "draw-all"))
    {
        drawAllCommand(in);
    }
    else if(!strcmp(in[0], "draw"))
    {
        drawCommand(in);
    }
    else if(!strcmp(in[0], "relationship"))
    {
        relationshipCommand(in);
    }
    else if(!strcmp(in[0], "list"))
    {
        listCommand(in);
    }
    else if(!strcmp(in[0], "quit"))
    {
        quitCommand(in);
        return SUCCESSFUL;
    }
    else if(!strcmp(in[0],"EOF"))
    {
        eofCommand(in);
    }
    else // maybe not needed
    {
        // if non existent command typed, it should be just ignored
        printf("non existing command\n");
    }

    return 1;
}
///////////////////////////////////////////////////////////////
//  MAIN MAIN MAIN MAIN MAIN MAIN MAIN MAIN MAIN MAIN MAIN   //
//                                                           //
///////////////////////////////////////////////////////////////
int main(int argc, char* argv[])
{
    char* copy_input = NULL;
    int len_max = 256;
    int error = 1;
    char* input = (char*) malloc(len_max* sizeof(char)); // memory for input, used for storing of commands
    FILE* fp;

    if (input == NULL)
    {
        printf("[ERR] Out of memory.\n");
        return 2;
    }
    if (argc == 1) // if the program started only with './ass', load the input from user
    {
        while(1)
        {
            printf("esp> "); // read last char \n as \0 so "esp>" does not skip a line
            char read[len_max];
            input = fgets(read, len_max, stdin);
            int len = strlen(read);

            if(read[len-1] == '\n')
            {
                read[len-1] = '\0';
            }
            copy_input = input;

            error = handleUserInput (copy_input);
            if(error == 0)
            {
                copy_input = NULL;
                input = NULL;
                //  free(copy_input);
                free(input);
                free(copy_input);
                return 0;
            }
            free(copy_input);
        }
    }
    else if (argc == 2) // checks parameters when starting program
    {
        const char* dot = strrchr(argv[1], '.'); // checks for '.' (dot) and stores it in *dot

        if (strcmp(dot, ".dot") == 0) // if '.dot' exists:
        {
            printf("%s\n", dot);
            fp = fopen(argv[1], "a+"); // a+ opens file for reading and writing
        }
        else if (strcmp(dot, ".dot"))
        {
            printf("Usage: ./ass [file-name]\n");
            return 2;
        }

    }
    else if (argc > 2)
    {
        printf("Usage: ./ass [file-name]\n");
        return 1;
    }
    free(input);
    return 0;
}




